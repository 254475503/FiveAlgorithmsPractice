package com.sohu.yifanshi.test.heapSort;

public class heapSortFun {
    public int[] nums;
    heapSortFun(int[] nums)
    {
        this.nums = nums;
    }

    /*堆排序
    * 堆排序的操作建立在一个数组满足堆的性质
    * 所谓堆，用一个完全二叉树来表示。这个完全二叉树中所有非叶子节点的值均不大于或均不小于其左右孩子的值。
    * 将这个二叉树在数组中表示的话，比如说整个树的根节点的下标为1，那么根节点下面的左子树下标为2*1，右子节点为2*1+1
    * 以此类推放入一个数组中，这样就用数组存储了一个堆。(所有完全二叉树与正二叉树都可以这样来表示。)
    * */

    //筛选调整堆。在左右子树为堆的情况下，将根节点与左右子节点比较，
    //将最大的置为根节点，但是如果左右节点与根节点进行交换以后，交换的那个子节点可能就会不满足堆的性质，就必须以这个
    //交换后的子节点为根节点做堆的筛选调整。
    public void maxHeap(int[] nums/*堆*/, int n/*堆中节点数*/, int rootNode/*根节点*/)
    {
        int left = rootNode*2;
        int right = rootNode*2+1;
        int largest = left;//此时largest无意义。
        if(left>n)//如果左子树的索引都大于堆中节点数，说明此节点本身就是一个叶子节点，没有左右子树，肯定满足堆性质，直接return
            return;
        if(right<n && nums[right]>nums[left])//选出左右子节点中最大的，去与根节点比较。并且记下最大的子节点是哪一个，方便
            //之后对子节点的筛选调整
            largest = right;
        if(nums[largest]>nums[rootNode])//如果最大的子节点大于根节点，就将其值交换，并且对子节点进行对筛选调整
        {
            int temp = nums[largest];
            nums[largest] = nums[rootNode];
            nums[rootNode] = temp;
            maxHeap(nums,n,largest);//筛选调整被交换过的子节点。
        }
    }

    //建堆操作。建堆操作就是基于堆的筛选调整之上的。建堆其实就是我们自下而上
    //一步一步的将节点全部进行一次筛选调整的过程。让一个无序的数组满足堆的性质的过程。我们来看

    public void creatHeap(int[] nums,int n)
    {
        for(int i = n/2 ; i > 0 ; i--)//为什么从n/2开始往上建堆呢？因为大于n/2索引的节点全部都是叶子节点。叶子节点无需
            //进行筛选调整
            maxHeap(nums,n,i);
    }




    //有了建堆操作，那么堆排序也基本出来了。堆的最大性质是什么？堆的根节点一定是这个
    //数组中最大或者最小的。我们在想想简单排序。就是从一堆数组中无策略的选出其中最大或者最小值，放在未排序部分的最
    //前面的部分。那我们的堆排序呢？其实就是简单排序的优化版。我们是有策略的选出最大或者最小值。利用了二叉树的优越性。
    //堆排序的选最大最小值就在堆的筛选调整中，堆筛选调整的最大时间复杂度也就是log2n(以2为底n的对数)。此时我们来说清楚堆
    // 排序的过程
    //我们从堆中拿出他的根节点，与末尾节点交换。然后再以这个堆的长度-1为长度 对这个调整过的堆进行从根节点开始的调整堆(\
    // 因为我们只交换了头尾节点，所以除了根节点以外，其左右子树都是符合堆的，所以我们只要从根节点开始筛选调整就可以保证调整
    // 完毕以后又是一个堆。)然而细节就在我们再次进行调整堆时候长度-1了，也就是之前被换到尾部的根节点是不会被调整的，他
    //就好像被从这个堆中删除了一样，每次调整到尾部的都是当前堆的最大或最小值，这不就排序了嘛？这就是堆排序。
    //至于堆排序的时间复杂度我们来分析一下。堆一共有n个节点，也就是按照这样每次-1的进度，我们要进行n次筛选调整。所以时间
    //复杂度为n*log2n，但是在进行堆排序之前，必须先要建堆 建堆的时间复杂度为(n/2)*log2n 所以时间复杂度为(3n/2)*log2n 最后
    //标准表达方式的时间复杂度就为o(n*log2n) 接下来 看代码把

    public void heapSort(int[] nums)
    {
        creatHeap(nums,nums.length-1);//0号位节点不再堆内，所以-1
        for(int i = nums.length-1; i >=2 ; i--)
        {
            int temp = nums[1];
            nums[1] = nums[i];
            nums[i] = temp;//每次将第一位与堆的最后一位进行交换。
            maxHeap(nums,i-1,1);
        }
    }


}
