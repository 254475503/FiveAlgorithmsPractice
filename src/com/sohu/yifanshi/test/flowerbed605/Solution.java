package com.sohu.yifanshi.test.flowerbed605;

public class Solution {
    /*
    * 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。
示例 1:
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
示例 2:
输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
    * */
    //对于这一题，我最开始的思考是这样的。找出所有能种花的位置，能种花的位置只有旁边没有1的0可以。所以我当时就想当然的把1旁边的0全部去掉，剩下的0
    //可以自由种花，然后再考虑不能重合种花的问题。但是很快我发现我想错了。类似100010001.按照我的算法来算有2个位置可以种花，那么最多可以1颗。
    //实际呢？这两个位置都可以种花，能中两颗。那么我思路就死在这了。后来我想，我只以1来进行考虑了，为何步用0来考虑呢？我把每一段连续的0都计算一遍他
    //能中多少颗花，这样遍历数组，然后把每段能种多少颗花加起来不就完事儿了？完美解决方案！实际上也是完美的，再leetcode上超过百分之97的人的效率，最快
    //7ms我只花了8ms。
    public static boolean canPlaceFolwers(int[] flowerbed, int n)
    {
        int canFlowers = 0;//数组中能种多少花
        for(int i = 0; i < flowerbed.length ; i++)//遍历数组，碰到0就进第二重循环，循环到下一个1出现。最后将i的位置设置为下一个1的后面一位。
            //从其后面一位开始下一次循环。这样虽然是双重循环但是复杂度却仅仅是o(n);
        {
            if(flowerbed[i]==0)//如果数组中循环到值为0
            {
                int count0 = 1;
                int k = i+1;
                for(; k < flowerbed.length ; k++)//第二重循环，循环到1结束或者出界。
                {
                    if(flowerbed[k]==1)
                        break;
                    count0++;
                }
                //算法重点在这。第二重循环结束后，一共有三种连续0的情况。第一种10000001这种i是在第二位的0，k是再最后一个1。这种情况要删除首尾两个0
                //第二中情况是000000全部为0。这种情况所有0都是有效位，不能减去任何一个0.
                //第三，四种情况是100000(i为第二位的0，k循环出界)，或者000001(i为第一个0，k位那个1)这种情况有一个0是靠在数组边界的，所以只需减少1个0
                if(i==0&&k<flowerbed.length||i!=0&&k==flowerbed.length)//k小于flowerbed.length代表k循环到了值为1的地方推出循环此时情况为0000001
                    // (0前面没有数)只需要-1而i!=0说明前面有1，k==flowerbed.length说明循环出界，也只要-1.这里对应3，4情况
                    count0--;
                else if(i!=0||flowerbed.length!=k)//第二个情况就是i==0&&k==flowerbed.length这种情况不用多于操作我就不写了。那么第一种情况就是除去
                    //2，3，4种情况以后剩下的情况被，那直接elseif情况2的逆否命题就完事儿了。也就是我现在写的那个样子。
                    count0-=2;

                if(count0>0)//count小于0就不用凑热闹了。直接滚
                {
                    if(count0%2==0)
                        canFlowers += count0/2;
                    else
                        canFlowers += count0/2+1;
                }
                i = k;//将i设为k，此时i要么出界，要么指向下一个1，1又不用看，刚好利用循环的++将这个1跳过，完美。这样让复杂度绝对等于o(n)
            }
        }
        if(canFlowers<n)
            return false;
        else
            return true;
    }


}
