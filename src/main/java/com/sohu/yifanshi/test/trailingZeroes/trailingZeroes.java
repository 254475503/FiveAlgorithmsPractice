package com.sohu.yifanshi.test.trailingZeroes;

public class trailingZeroes {//求一个数的阶乘后面有多少0.比如3！没有0 5！有一个0 25的阶乘有6个0
    //这道题重在分析，我们要想0是怎么来的。零在阶乘中无非两个来源。一个2*5，还一个*0的时候。这是我最初的想法。如果这样算的话，每10的阶乘就有两个0
    //但是这样分析属实笨比！在20之前，的确是每10的阶乘就有一个0，但是当阶乘来到25了呢？25*4=两个5*2，会出两个0嗷，125*8的话等于（2*5）^3 有三个零嗷。
    //所以我们总结一下。阶乘中，每乘以一个5的倍数，那么就会出现一个0。每乘以一个5^2的倍数，就会出现两个0。没乘以一个5^3的倍数，就会出现三个0.
    //这样分析完，我们只需要找出5以及其指数的倍数在这个阶乘中有多少个并且分类就行了。这样我们不免陷入一个困境。25既是5的倍数又是25的倍数。如果我们
    //一个一个去求5每个指数的倍数，并且用每个指数的个数分别乘以他们生成的0的数量，就会算重。比如25！ 25有5，10，15，20，25是5的倍数这就5个了。25又是25
    //的倍数，生成2个0.加起来就7个0.但是25！只有6个0.这就多算了一遍。若要将25的倍数从5的倍数中取出，代价未免太大。但是我们仔细观察发现。5的倍数生成1个0
    //25的倍数生成2个0，比5的倍数多一个。我们先算一遍5的倍数个数，再算一遍25的倍数。5倍数与25倍数算重的那一部分？不正好就加了2嘛？同理，同时是5，25，125
    //倍数的数，会呗这样算重三次，这不就刚刚好加了3嘛？所以我们只要将阶乘中5的倍数个数，125倍数个数，625倍数个数。。。依此加起来。就完事儿了。于是，
    //算法如下嗷。
    public static int trailingZeroes(int num)
    {
        int count = 0;
        while(num!=0)
        {
            num = num/5;//一个数除以5的整数部分就代表着这个数中有多少个5的倍数。
            count +=num;//这种类似的算法，其复杂度都为logn。
        }
        return count;
    }
}
